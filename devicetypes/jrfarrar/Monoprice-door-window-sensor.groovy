/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "01.00.00"
}

/**
 * Monoprice Door/Window Sensor
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2017-8-7 - (v01.00.00) Initial release
 */

preferences {
    input title: "", description: "Monoprice Door/Window Sensor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "Some devices (e.g. 15270) can use an external wired sensor instead of the magnet sensor to trigger the open/close state.\nNOTE: To use the external wire sensor you MUST attach the magnet sensor to the device.", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "externalSensor", "bool", title: "External wired sensor", displayDuringSetup: false, required: false
}

metadata {
	definition (name: "Monoprice Door/Window Sensor", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "x.com.st.d.sensor.contact") {
		capability "Configuration"
		capability "Contact Sensor"
		capability "Sensor"
		capability "Battery"
        capability "Tamper Alert"
        
        attribute "codeVersion", "string"
        attribute "dhName", "string"

        fingerprint deviceId:"0x0701", inClusters:"0x5E,0x98,0x86,0x72,0x5A,0x85,0x59,0x73,0x80,0x71,0x84,0x7A", manufacturer: "Monoprice", model: "15268" // Z-Wave Plus Motion recessed Door/Windows sensor
        fingerprint deviceId:"0x0701", inClusters:"0x72,0x5A,0x80,0x73,0x86,0x84,0x85,0x59,0x71,0x70,0x7A", manufacturer: "Monoprice", model: "15270" // Z-Wave Plus Motion Door/Windows sensor
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0701", cc:"5E,98", sec:"86,72,5A,85,59,73,80,71,84,7A", mfr: "0109", prod: "2022", model: "2201", deviceJoinName:"Monoprice Z-Wave Plus Recessed Door/Window Sensor (15268)"
        fingerprint type:"0701", cc:"5E,98", sec:"72,5A,80,73,86,84,85,59,71,70,7A", mfr: "0109", prod: "2001", model: "0106", deviceJoinName:"Monoprice Z-Wave Plus Door/Window Sensor (15270)"
	}

	// UI tile definitions
    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4, canChangeIcon: true) {
            tileAttribute ("device.contact", key: "PRIMARY_CONTROL") {
                attributeState "open", label: '${name}', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
                attributeState "closed", label: '${name}', icon: "st.contact.contact.closed", backgroundColor: "#00A0DC"
            }
            tileAttribute ("device.battery", key: "SECONDARY_CONTROL") {
				attributeState "battery", label:'${currentValue}%'
            }
        }
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'\n ${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png",
                backgroundColors:[
                    [value: 15, color: "#ff0000"],
                    [value: 30, color: "#fd4e3a"],
                    [value: 50, color: "#fda63a"],
                    [value: 60, color: "#fdeb3a"],
                    [value: 75, color: "#d4fd3a"],
                    [value: 90, color: "#7cfd3a"],
                    [value: 99, color: "#55fd3a"]
                ]
        }
		standardTile("contact", "device.contact", width: 4, height: 4, inactiveLabel: false) {
			state "open", label: '${name}', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
			state "closed", label: '${name}', icon: "st.contact.contact.closed", backgroundColor: "#00A0DC"
		}
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "clear", label:'Request update', action:"configure", backgroundColor:"#FFFFFF", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
		}

		main "contact"
        details(["contact", "battery", "tamper"])
	}
}

def parse(String description) {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Monoprice Door/Window Sensor Device Handler"]) // Save DH Name for parent app

	def result = null
	if (description.startsWith("Err 106")) {
		if (state.security) {
			log.debug description
		} else {
			result = createEvent(
				descriptionText: "This sensor failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
				eventType: "ALERT",
				name: "secureInclusion",
				value: "failed",
				isStateChange: true,
			)
		}
	} else if (description != "updated") {
		def cmd = zwave.parse(description, [0x20: 1, 0x25: 1, 0x30: 2, 0x80: 1, 0x84: 2, 0x71: 3, 0x9C: 1, 0x70: 1])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}
    log.debug "Parse returned ${result}"
	return result
}

def installed() {
	log.trace "Installed called settings: $settings"
	response(configure())
}

def updated() {
	log.trace "Update called settings: $settings"
	response(configure())
}

def configure() {
	log.trace "Configure called"
    
    state.setConfig = true // Set the config at next wakeup
    state.forceRefresh = true // Reset it to force a battery update on the next wake up
    
    // Configure is called at inclusion so we have a SMALL window to execute some commands here, won't make any differnce when called manually
    def cmds = []

    cmds += commands([
        zwave.batteryV1.batteryGet(),
        zwave.manufacturerSpecificV2.manufacturerSpecificGet()
    ], 500) // Small delay works since typically at inclusion the sensor is near the hub for the NIF command so there's no routing involved here

    // Don't do a no more wakeup here as the hub ends up queueing it becase it's a passive device and it interfers with the wakup command due to a delayed retry from the hub, the device will timeout by itself in 10 seconds
    //cmds << "delay 3000"
    //cmds << command(zwave.wakeUpV1.wakeUpNoMoreInformation()) // We're done here
    
    return cmds
}


def sensorValueEvent(value) {
	if (value) {
		createEvent(name: "contact", value: "open", descriptionText: "$device.displayName is open")
	} else {
		createEvent(name: "contact", value: "closed", descriptionText: "$device.displayName is closed")
	}
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
	log.trace "BasicReport: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd)
{
	log.trace "BasicSet: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
	log.trace "SwitchBinaryReport: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.sensorbinaryv2.SensorBinaryReport cmd)
{
	log.trace "SensorBinaryReport: $cmd"
	sensorValueEvent(cmd.sensorValue)
}

def zwaveEvent(physicalgraph.zwave.commands.sensoralarmv1.SensorAlarmReport cmd)
{
	log.trace "SensorAlarmReport: $cmd"
	sensorValueEvent(cmd.sensorState)
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd)
{
	log.trace "NotificationReport: $cmd"
	def result = []
	if (cmd.notificationType == 0x06 && (cmd.event == 0x16 || cmd.event == 0x17)) {
		result << sensorValueEvent(cmd.v1AlarmLevel) // Duplicate to BasicSet, whichever comes faster
	} else if (cmd.notificationType == 0x07) {
        if (cmd.event == 0x03) { // Bug, eventParameter is supposed to be 0x03 but it doesn't send it
            result << createEvent(name: "tamper", value: "detected", descriptionText: "$device.displayName covering was removed", isStateChange: true)
            state.forceRefresh = true // When the device is opened physically force a sensor refresh
		} else if (cmd.event == 0x00) {
            result << createEvent(name: "tamper", value: "clear", descriptionText: "$device.displayName covering was closed", isStateChange: true)
        }
	} else if (cmd.notificationType) {
		def text = "Notification $cmd.notificationType: event ${([cmd.event] + cmd.eventParameter).join(", ")}"
		result << createEvent(name: "notification$cmd.notificationType", value: "$cmd.event", descriptionText: text, displayed: false)
	} else {
		def value = cmd.v1AlarmLevel == 255 ? "active" : cmd.v1AlarmLevel ?: "inactive"
		result << createEvent(name: "alarm $cmd.v1AlarmType", value: value, displayed: false)
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
	log.debug "Device woke up"
    
	def event = createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)
	def cmds = []

    if (!state.MSR) {
        log.debug "Getting device MSR"
		cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet()
	} else {
        log.debug "Saved MSR: $state.MSR"
    }

    if (state.setConfig) { // Set configuration
        if (state.MSR == "0109-2001-0106") { // Only the 15270 supports external sensor
            if (externalSensor) {
                log.info "Enabling external sensor"
                cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0xFF]) // Set external sensor
                cmds << zwave.configurationV1.configurationGet(parameterNumber: 1) // Confirm
            } else {
                log.info "Disabling external sensor"
                cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0x0]) // Set external sensor
                cmds << zwave.configurationV1.configurationGet(parameterNumber: 1) // Confirm inactivity timeout
            }
        }

        state.setConfig = false // We're done, dont' update again unless requested
    }

	if (state.forceRefresh || (device.currentValue("contact") == null)) { // Incase our initial request didn't make it or we are asking for a refresh
        log.debug "Getting sensor state"
		cmds << zwave.sensorBinaryV2.sensorBinaryGet(sensorType: zwave.sensorBinaryV2.SENSOR_TYPE_DOOR_WINDOW)
	}

    // Get battery updates every 24 hours to save battery
	if (state.forceRefresh || !state.lastbat || (now() - state.lastbat > 24*60*60*1000)) {
        log.debug "Getting battery level"
        cmds << zwave.batteryV1.batteryGet()
    }
    cmds << zwave.wakeUpV2.wakeUpNoMoreInformation()
    
    state.forceRefresh = false // We're done until the next request

	[event, getResponses(cmds)]
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "BatteryReport: $cmd"
    
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbat = now()
	[createEvent(map)]
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)

    if (!device.currentState("battery")) {
        result << getResponse(zwave.batteryV1.batteryGet())
    }

	result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    def msg = null
    switch (cmd.parameterNumber) {
        case 1:
        	switch (cmd.configurationValue[0]) {
                case 0xFF:
	        		msg = "External wire sensor Enabled, Magnet sensor Disabled"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
    	            break
                
                case 0x0:
	        		msg = "External wire sensor Disabled, Magnet sensor Enabled"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break

                default:
                    log.warn "Invalid External Sensor Mode: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        default:
            log.warn "Unknown parameter"
            break
    }
    
    log.info msg
    result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x20: 1, 0x25: 1, 0x30: 2, 0x80: 1, 0x84: 2, 0x71: 3, 0x9C: 1, 0x70: 1])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		state.security = true
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unhandled command: $cmd"
	createEvent(descriptionText: "$device.displayName: $cmd", displayed: false)
}

private getResponses(commands, delay=1200) {
    if (state.security) {
        response(delayBetween(commands.collect{ zwave.securityV1.securityMessageEncapsulation().encapsulate(it).format() }, delay))
    } else {
        response(delayBetween(commands.collect{ it.format() }, delay))
    }
}

private getResponse(command) {
    if (state.security) {
        response(zwave.securityV1.securityMessageEncapsulation().encapsulate(command).format())
    } else {
        response(command.format())
    }
}

private command(physicalgraph.zwave.Command cmd) {
	if (state.security) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private commands(commands, delay=200) {
	delayBetween(commands.collect{ command(it) }, delay)
}